#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 31 18:28:19 2020

@author: dcoster
"""

from keras.models import Sequential
from keras.layers import Convolution2D
from keras.layers import MaxPooling2D
from keras.layers import Flatten
from keras.layers import Dense
from keras.preprocessing.image import ImageDataGenerator
import numpy as np
from keras.preprocessing import image
import os

# Defining the variable to save the model
DIR_NAME = 'TrainedModel/'
MODEL_NAME = 'CatDogModel'
OVERRIDE_MODEL = True

# initializing the classifier or model
classifier = Sequential()

# adding a convolution layer for feature matrix
classifier.add(Convolution2D(32, 3, 3, input_shape=(64, 64, 3), activation='relu'))
# performing a max pooling to reduce the matrix of feature size
classifier.add(MaxPooling2D(pool_size=(2, 2)))
# adding a second layer of convolution layer to increase the performance of the CNN
classifier.add(Convolution2D(32, 3, 3, activation='relu'))
# adding second layer of Pooling for the convolution layer
classifier.add(MaxPooling2D(pool_size=(2, 2)))
# flattening the features to make different matrix or inputs for neural network
classifier.add(Flatten())
# adding the first layer of the NN that takes 128 features input using relu as it is best for classification
classifier.add(Dense(units=128, activation='relu'))
# setting up the output layer of the NN as it outputs from only one node describing the probability of wheather it is cat or dog in binary
classifier.add(Dense(units=1, activation='sigmoid'))
# compiling the NN using adam optimizer and binary crossentrophy as loss function as the output is in binary cats or dogs
# if there were more than 2 outputs than classification crossentrophy should be used and use softmax
# in the last layer as it gives the total probability in range between 0-1
classifier.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
# using the keras library to make the images more diverse in training process as it rescale shears zooms and flips
# it creates a variety of non repetable data to work on providing a better training set of datas
train_datagen = ImageDataGenerator(
    rescale=1. / 255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True)
# generating the similar diverse images for the test set as it rescales the images to make it more dynamic
test_datagen = ImageDataGenerator(rescale=1. / 255)
# collecting all the images from the described folder to a batch size of 32 and resize the images as per the inputs of
# the newural networks input shape defined as 64,64,3 which means height and width of 64 by 64 pixels
training_set = train_datagen.flow_from_directory(
    'dataset/training_set',
    target_size=(64, 64),
    batch_size=32,
    class_mode='binary')
# same processing technique as the training set as it the neural network takes the input of 64 by 64 pixels
test_set = test_datagen.flow_from_directory(
    'dataset/test_set',
    target_size=(64, 64),
    batch_size=32,
    class_mode='binary')
# fitting the generated data  to the neural network here steps_per_epoch means the no of training dataset
classifier.fit_generator(training_set,
                         steps_per_epoch=8000,
                         epochs=25,
                         validation_data=test_set,
                         validation_steps=2000)
# -------------------------------------------------------------------
# creating a folder to save the model
try:
    os.makedirs(DIR_NAME)
    print('Directory Created Successfully')

except FileExistsError:
    print("The Directory Already Exists")

# ----------------------------------------------------------------------
# saving the model to trained model folder
classifier.save(DIR_NAME + '/' + MODEL_NAME, overwrite=[OVERRIDE_MODEL])
# testing the model generated by the neural network and resizing as the NN takes inputs of 64 by 64 size only
test_image = image.load_img('dataset/single_prediction/cat_or_dog_1.jpg', target_size=(64, 64))
# converting the images to an array of data
test_image = image.img_to_array(test_image)
# adding a new dimension as the keras library uses 4D array
test_image = np.expand_dims(test_image, axis=0)
# using the generated mode/classifier to predict the images
prediction = classifier.predict(test_image)
# class_indices gives the numeric value of the trained classes in this case numeric value for cats and dogs
training_set.class_indices
# output in more understandable form
if prediction[0][0] == 1:
    prediction = 'dog'
else:
    prediction = 'cat'
